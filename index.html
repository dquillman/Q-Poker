<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Texas Hold'em Poker - 9 Players</title>
  <link rel="stylesheet" href="index.css">
</head>

<body>
  <div class="header">
    <h1>Q-Poker <span id="versionDisplay" class="version-tag"></span></h1>
    <div class="header-controls">
      <button id="historyBtn" class="history-btn" onclick="toggleHistory()">Hand History</button>
      <button id="statsBtn" class="history-btn" onclick="toggleAnalytics()">Stats</button>
      <button id="drillsBtn" class="history-btn" onclick="toggleDrills()">Drills</button>
      <button id="rangeBtn" class="history-btn" onclick="toggleRanges()">Range Vis</button>
      <button id="chartsBtn" class="history-btn" onclick="toggleCharts()">Charts</button>
      <button id="mathBtn" class="history-btn" onclick="toggleMath()">Math</button>
      <a href="how-to-use.html" class="history-btn" style="text-decoration:none;">Mastery Guide</a>
    </div>
    <p>9-Player Table</p>
    <button class="sound-toggle" id="soundToggle" title="Toggle Sound">
      <span class="sound-icon">üîä</span>
    </button>
    <button class="coach-toggle" id="coachToggle" title="Toggle Coach Mode">
      <span class="coach-icon">üéì</span> Coach
    </button>
    <div class="bankroll-display" id="bankrollDisplay" title="Career Bankroll">
      <span class="bankroll-icon">üí∞</span> <span id="bankrollValue">$50</span>
    </div>
  </div>

  <div class="game-container">
    <!-- Decision Flow Chart -->
    <div class="decision-flow" id="decisionFlow">
      <div class="flow-header">üß† Decision Matrix</div>

      <div class="flow-step" id="step-position" onclick="showTrainingForm('position')">
        <div class="step-icon">üìç</div>
        <div class="step-content">
          <div class="step-title">Position Check</div>
          <div class="step-desc" id="flow-pos-desc">Waiting...</div>
        </div>
      </div>

      <div class="flow-step" id="step-preflop" onclick="showTrainingForm('preflop')">
        <div class="step-icon">üÉè</div>
        <div class="step-content">
          <div class="step-title">Range Analysis</div>
          <div class="step-desc" id="flow-preflop-desc">Check GTO Chart</div>
        </div>
      </div>

      <div class="flow-step" id="step-math" onclick="showTrainingForm('math')">
        <div class="step-icon">üìä</div>
        <div class="step-content">
          <div class="step-title">Pot Odds vs Equity</div>
          <div class="step-desc" id="flow-math-desc">Rule of 2 & 4</div>
        </div>
      </div>

      <div class="flow-step" id="step-decision" onclick="showTrainingForm('decision')">
        <div class="step-icon">‚ö°</div>
        <div class="step-content">
          <div class="step-title">Final Decision</div>
          <div class="step-desc" id="flow-decision-desc">Optimal Action</div>
        </div>
      </div>
    </div>

    <!-- Pot Display -->
    <div class="pot-display" id="potDisplay">
      <div class="pot-label">POT</div>
      <div class="pot-amount">$0</div>
    </div>

    <div class="poker-table" id="pokerTable">
      <!-- Community Cards -->
      <div class="community-cards" id="communityCards"></div>

      <!-- Dealer Button -->
      <div class="dealer-button" id="dealerButton" style="display: none;">D</div>

      <!-- Player Positions (9 players) -->
      <div class="player-position player-0" id="player-0">
        <div class="player-info">
          <div class="player-name">You</div>
          <div class="player-chips">$1000</div>
          <div class="player-hand-rank"></div>
          <div class="player-current-bet"></div>
        </div>
        <div class="player-cards"></div>
      </div>

      <div class="player-position player-1" id="player-1">
        <div class="player-info">
          <div class="player-name">Player 2</div>
          <div class="player-chips">$1000</div>
          <div class="player-hand-rank"></div>
          <div class="player-current-bet"></div>
        </div>
        <div class="player-cards"></div>
      </div>

      <div class="player-position player-2" id="player-2">
        <div class="player-info">
          <div class="player-name">Player 3</div>
          <div class="player-chips">$1000</div>
          <div class="player-hand-rank"></div>
          <div class="player-current-bet"></div>
        </div>
        <div class="player-cards"></div>
      </div>

      <div class="player-position player-3" id="player-3">
        <div class="player-info">
          <div class="player-name">Player 4</div>
          <div class="player-chips">$1000</div>
          <div class="player-hand-rank"></div>
          <div class="player-current-bet"></div>
        </div>
        <div class="player-cards"></div>
      </div>

      <div class="player-position player-4" id="player-4">
        <div class="player-info">
          <div class="player-name">Player 5</div>
          <div class="player-chips">$1000</div>
          <div class="player-hand-rank"></div>
          <div class="player-current-bet"></div>
        </div>
        <div class="player-cards"></div>
      </div>

      <div class="player-position player-5" id="player-5">
        <div class="player-info">
          <div class="player-name">Player 6</div>
          <div class="player-chips">$1000</div>
          <div class="player-hand-rank"></div>
          <div class="player-current-bet"></div>
        </div>
        <div class="player-cards"></div>
      </div>

      <div class="player-position player-6" id="player-6">
        <div class="player-info">
          <div class="player-name">Player 7</div>
          <div class="player-chips">$1000</div>
          <div class="player-hand-rank"></div>
          <div class="player-current-bet"></div>
        </div>
        <div class="player-cards"></div>
      </div>

      <div class="player-position player-7" id="player-7">
        <div class="player-info">
          <div class="player-name">Player 8</div>
          <div class="player-chips">$1000</div>
          <div class="player-hand-rank"></div>
          <div class="player-current-bet"></div>
        </div>
        <div class="player-cards"></div>
      </div>

      <div class="player-position player-8" id="player-8">
        <div class="player-info">
          <div class="player-name">Player 9</div>
          <div class="player-chips">$1000</div>
          <div class="player-hand-rank"></div>
          <div class="player-current-bet"></div>
        </div>
        <div class="player-cards"></div>
      </div>
    </div>

    <div class="status-message" id="statusMessage">Click "New Hand" to start playing!</div>

    <!-- Stats Displays and Advisor Panel moved to body -->
  </div>

  <!-- Stats Displays (Fixed Overlays) -->
  <div class="equity-display" id="equityDisplay" style="display: none;">
    <div class="equity-label">Win Probability</div>
    <div class="equity-meter">
      <div class="equity-fill" id="equityFill"></div>
    </div>
    <div class="equity-text" id="equityText">0%</div>
    <div class="pot-odds-indicator" id="potOddsIndicator"></div>
  </div>

  <div class="outs-display" id="outsDisplay" style="display: none;">
    <div class="outs-header">üéØ Outs Calculator</div>
    <div class="outs-total" id="outsTotal">0 outs</div>
    <div class="outs-breakdown" id="outsBreakdown"></div>
    <div class="rule-of-24" id="ruleOf24"></div>
    <div class="implied-odds" id="impliedOdds"></div>
    <div class="outs-classification" id="outsClassification"></div>
  </div>

  <!-- Decision Advisor Panel -->
  <div class="advisor-panel" id="advisorPanel" style="display: none;">
    <div class="advisor-header">üí° Coach Recommendation</div>
    <div class="advisor-action" id="advisorAction">CALL</div>
    <div class="advisor-confidence" id="advisorConfidence">Confidence: High</div>
    <div class="advisor-explanation" id="advisorExplanation">Your 67% equity justifies calling $50.</div>
    <div class="advisor-alternatives" id="advisorAlternatives"></div>
    <div class="advisor-info-buttons">
      <button class="info-btn" id="equityInfoBtn" title="Learn how equity is calculated">
        <span class="info-icon">‚ÑπÔ∏è</span> How is Equity Calculated?
      </button>
      <button class="info-btn" id="evInfoBtn" title="Learn how EV is calculated">
        <span class="info-icon">‚ÑπÔ∏è</span> How is EV Calculated?
      </button>
    </div>
  </div>

  <!-- Explanation Modal -->
  <div class="explanation-modal" id="explanationModal" style="display: none;">
    <div class="explanation-content">
      <button class="explanation-close" id="explanationClose">√ó</button>
      <h2 id="explanationTitle">Calculation Explanation</h2>
      <div id="explanationBody"></div>
    </div>
  </div>

  <!-- Player Action Controls -->
  <div class="player-controls" id="playerControls" style="display: none;">
    <button class="btn btn-danger" id="foldBtn">Fold</button>
    <button class="btn btn-secondary" id="checkBtn">Check</button>
    <button class="btn btn-secondary" id="callBtn">Call $<span id="callAmount">0</span></button>
    <div class="bet-controls">
      <input type="number" id="betAmount" min="10" step="10" value="50" placeholder="Bet amount">
      <button class="btn" id="betBtn">Bet</button>
      <button class="btn" id="raiseBtn">Raise</button>
    </div>
    <div class="min-raise-info" id="minRaiseInfo" style="display: none;">
      Minimum raise: $<span id="minRaiseAmount">20</span>
    </div>
  </div>

  <!-- Game Controls -->
  <div class="controls">
    <button class="btn" id="newHandBtn">New Hand</button>
    <button class="btn btn-secondary" id="nextPhaseBtn" style="display: none;">Next Phase</button>
    <button class="btn btn-secondary" id="showWinnerBtn" style="display: none;">Show Winner</button>
  </div>


  <!-- Game Over Modal -->
  <div class="game-over-modal" id="gameOverModal" style="display: none;">
    <div class="game-over-content">
      <h1 id="gameOverTitle">üèÜ Game Over</h1>
      <div class="placement-display" id="placementDisplay"></div>
      <div class="game-stats" id="gameStats"></div>
      <button class="btn btn-primary" id="playAgainBtn">Play Again</button>
    </div>
  </div>

  <!-- Hand History Modal -->
  <div id="historyModal" class="modal">
    <div class="modal-content history-content">
      <span class="close-btn" onclick="toggleHistory()">&times;</span>
      <h2>Hand History</h2>
      <div class="history-container">
        <div id="historyList" class="history-list">
          <!-- List of hands will go here -->
          <p>No hands played yet.</p>
        </div>
        <div id="historyDetail" class="history-detail" style="display:none;">
          <button onclick="backToHistoryList()" class="back-btn">‚Üê Back</button>
          <div id="detailContent"></div>
        </div>
      </div>
    </div>
  </div>


  <!-- Training Modal -->
  <div id="trainingModal" class="modal">
    <div class="modal-content training-content">
      <span class="close-btn" onclick="toggleModal('trainingModal')">&times;</span>
      <h2 id="trainingTitle">Training Session</h2>
      <div id="trainingFormBody" class="training-form">
        <!-- Form injected here -->
      </div>
      <div id="trainingFeedback" class="feedback-area"></div>
      <button id="submitTrainingBtn" class="submit-training-btn" onclick="submitTrainingForm()">Submit Analysis</button>
    </div>
  </div>

  <!-- Analytics Modal -->
  <div id="analyticsModal" class="modal">
    <div class="modal-content history-content">
      <span class="close-btn" onclick="toggleAnalytics()">&times;</span>
      <h2>Leak Finder</h2>
      <div class="analytics-container">
        <div class="stat-card">
          <h3>VPIP</h3>
          <div class="stat-value" id="vpipValue">0%</div>
          <p class="stat-desc">Voluntarily Put Money In Pot</p>
          <div class="stat-advice" id="vpipAdvice">Not enough data</div>
        </div>
        <div class="stat-card">
          <h3>PFR</h3>
          <div class="stat-value" id="pfrValue">0%</div>
          <p class="stat-desc">Pre-Flop Raise</p>
          <div class="stat-advice" id="pfrAdvice">Not enough data</div>
        </div>
        <div class="stat-card">
          <h3>Aggression</h3>
          <div class="stat-value" id="aggValue">0%</div>
          <p class="stat-desc">Bet% Postflop</p>
          <div class="stat-advice" id="aggAdvice">Not enough data</div>
        </div>
      </div>
      <div style="margin-top:20px; font-size: 0.9em; color:#888;">
        <p><strong>Targets:</strong> VPIP (20-30%), PFR (15-25%), Aggression (>20%)</p>
      </div>
    </div>
  </div>

  <!-- Drills Modal -->
  <div id="drillsModal" class="modal">
    <div class="modal-content history-content">
      <span class="close-btn" onclick="toggleDrills()">&times;</span>
      <h2>Drill Mode</h2>
      <p style="color:#aaa; text-align:center; margin-bottom:20px;">Practice specific tough spots.</p>

      <div class="drill-grid">
        <div class="drill-card" onclick="startDrill('river_call')">
          <h3>River Hero Call</h3>
          <p>Big pot. Scary board. Opponent shoves. Do you have the guts to call with Top Pair?</p>
        </div>
        <div class="drill-card" onclick="startDrill('flush_draw')">
          <h3>Chasing Flushes</h3>
          <p>You have a King-High flush draw on the flop. Opponent bets pot. What is the correct GTO play?</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Range Visualizer Modal -->
  <div id="rangeModal" class="modal">
    <div class="modal-content history-content range-modal-content">
      <span class="close-btn" onclick="toggleRanges()">&times;</span>
      <h2>Opponent Perceived Range</h2>
      <p style="color:#aaa; text-align:center;">Based on actions (Bet/Raise), we remove weak hands.</p>

      <div id="rangeGrid" class="range-grid">
        <!-- 13x13 Grid -->
      </div>

      <div class="range-legend">
        <span class="legend-item"><span class="color-box range-cell range-100"></span> 100%</span>
        <span class="legend-item"><span class="color-box range-cell range-50"></span> 50%</span>
        <span class="legend-item"><span class="color-box range-cell range-20"></span> 20%</span>
        <span class="legend-item"><span class="color-box range-cell range-0"></span> 0%</span>
      </div>
    </div>
  </div>

  <!-- Charts Modal -->
  <div id="chartsModal" class="modal">
    <div class="modal-content history-content">
      <span class="close-btn" onclick="toggleCharts()">&times;</span>
      <h2>Preflop Cheat Sheet</h2>
      <p style="color:#aaa; text-align:center;">Select your position to see the Opening Range.</p>

      <div class="position-selector">
        <button class="pos-btn" onclick="updateChart('UTG')">UTG</button>
        <button class="pos-btn" onclick="updateChart('HJ')">HJ</button>
        <button class="pos-btn" onclick="updateChart('CO')">CO</button>
        <button class="pos-btn" onclick="updateChart('BTN/SB/BB')">BTN/SB/BB</button>
      </div>

      <div id="chartDisplay" class="chart-display">
        <h3>Select a position...</h3>
      </div>

      <button class="btn btn-secondary" style="margin-top: 20px; width: 100%; border: 1px dashed var(--gold);"
        onclick="togglePositionGuide()">
        üìñ Position Guide & Definitions
      </button>

      <div id="positionGuide" class="position-guide" style="display: none;">
        <div class="guide-item">
          <strong>üìç UTG (Under the Gun):</strong> First to act preflop. You are "under pressure" and must play only the
          strongest hands.
        </div>
        <div class="guide-item">
          <strong>üìç HJ (Hijack) / MP:</strong> Middle position. You can "hijack" the action from late players. Slightly
          more flexibility.
        </div>
        <div class="guide-item">
          <strong>üìç CO (Cutoff):</strong> Late position. Just before the Dealer. Perfect for "cutting off" the blinds
          and stealing the pot.
        </div>
        <div class="guide-item">
          <strong>üìç BTN (Dealer Button):</strong> The Power Seat. You act last on every post-flop street, giving you
          the most information.
        </div>
        <div class="guide-item">
          <strong>üìç SB (Small Blind):</strong> Forced bet. Tough spot as you act first post-flop (Out of Position).
        </div>
        <div class="guide-item">
          <strong>üìç BB (Big Blind):</strong> Full forced bet. Last to act preflop, but out of position post-flop.
        </div>
      </div>
    </div>
  </div>

  <!-- Math Dojo Modal -->
  <div id="mathModal" class="modal">
    <div class="modal-content history-content">
      <span class="close-btn" onclick="toggleMath()">&times;</span>
      <h2>Poker Math Dojo</h2>
      <p style="color:#aaa; text-align:center;">Quick! Estimate your equity.</p>

      <div id="mathQuiz" class="math-quiz">
        <div class="quiz-streak">Streak: <span id="mathStreak">0</span></div>
        <div class="quiz-scenario">
          <div id="quizHand" class="hand-display"></div>
          <div id="quizBoard" class="community-cards" style="justify-content:center; margin:10px 0;"></div>
        </div>
        <div class="quiz-question">
          What is your Equity vs Random Hand?
        </div>
        <div class="quiz-options">
          <button class="quiz-btn" onclick="checkMathAnswer(0)">0-20%</button>
          <button class="quiz-btn" onclick="checkMathAnswer(20)">20-40%</button>
          <button class="quiz-btn" onclick="checkMathAnswer(40)">40-60%</button>
          <button class="quiz-btn" onclick="checkMathAnswer(60)">60-80%</button>
          <button class="quiz-btn" onclick="checkMathAnswer(80)">80-100%</button>
        </div>
        <div id="quizResult" class="quiz-result"></div>
        <button class="action-button" onclick="nextMathQuestion()" style="margin-top:20px; width:100%;">Next
          Hand</button>
      </div>
    </div>
  </div>

  <script src="sounds.js"></script>
  <script src="learning-engine.js"></script>
  <script src="poker.js"></script>
  <script>
    let game;
    let isProcessingAI = false;
    let isDealingCards = false;

    function createCardElement(card, faceDown = false) {
      const cardDiv = document.createElement('div');
      cardDiv.className = `card ${faceDown ? 'card-back' : card.color} dealing`;

      if (!faceDown) {
        cardDiv.innerHTML = `
          <div class="card-value">${card.value}</div>
          <div class="card-suit">${card.suit}</div>
          <div class="card-center">${card.suit}</div>
          <div class="card-value" style="align-self: flex-end; transform: rotate(180deg);">${card.value}</div>
        `;
      }

      return cardDiv;
    }

    function updatePotDisplay() {
      document.querySelector('.pot-amount').textContent = `$${game.pot}`;
    }

    function updateStatusMessage() {
      const msg = document.getElementById('statusMessage');
      const phaseNames = {
        'waiting': 'Waiting to start',
        'preflop': 'Pre-Flop Betting',
        'flop': 'Flop Betting',
        'turn': 'Turn Betting',
        'river': 'River Betting',
        'showdown': 'Showdown'
      };

      if (game.gamePhase === 'waiting') {
        msg.textContent = 'Click "New Hand" to start playing!';
      } else if (game.gamePhase === 'showdown' || game.inShowdownUI) {
        // Skip textContent update if we're showing winners via innerHTML
        return;
      } else {
        const currentPlayer = game.getCurrentPlayer();
        const actionText = currentPlayer.isHuman ? "'s turn" : " is thinking...";
        msg.textContent = `${phaseNames[game.gamePhase]} - ${currentPlayer.name}${actionText}`;
      }
    }

    function renderGame() {
      // Render community cards
      // Render community cards with differential update
      const communityCardsEl = document.getElementById('communityCards');
      const communityKey = game.communityCards.map(c => c.value + c.suit).join('-');

      if (communityCardsEl.dataset.renderKey !== communityKey) {
        communityCardsEl.dataset.renderKey = communityKey;
        communityCardsEl.innerHTML = '';
        game.communityCards.forEach((card) => {
          const cardEl = createCardElement(card);
          communityCardsEl.appendChild(cardEl);
        });
      }

      // Hide all player slots first
      for (let i = 0; i < 9; i++) {
        const playerEl = document.getElementById(`player-${i}`);
        if (playerEl) {
          playerEl.style.display = 'none';
        }
      }

      // Render each active player
      game.players.forEach((player, index) => {
        const playerEl = document.getElementById(`player-${player.id}`);
        if (!playerEl) return;

        // Show this player slot if not eliminated
        if (player.eliminated) {
          playerEl.style.display = 'none';
          return;
        }
        playerEl.style.display = 'block';

        const cardsContainer = playerEl.querySelector('.player-cards');
        const playerInfo = playerEl.querySelector('.player-info');
        const handRankEl = playerEl.querySelector('.player-hand-rank');
        const currentBetEl = playerEl.querySelector('.player-current-bet');

        // Update chips
        playerEl.querySelector('.player-chips').textContent = `$${player.chips}`;

        // Update current bet
        if (player.currentBet > 0) {
          currentBetEl.textContent = `Bet: $${player.currentBet}`;
          currentBetEl.style.display = 'block';
        } else {
          currentBetEl.style.display = 'none';
        }

        // Update or create bet chip display
        let betDisplay = playerEl.querySelector('.player-bet-display');
        if (!betDisplay) {
          betDisplay = document.createElement('div');
          betDisplay.className = 'player-bet-display';
          betDisplay.innerHTML = '<div class="bet-amount">$0</div>';
          playerEl.appendChild(betDisplay);
        }

        const betAmountEl = betDisplay.querySelector('.bet-amount');
        if (player.currentBet > 0) {
          betAmountEl.textContent = `$${player.currentBet}`;
          betDisplay.classList.add('visible');
        } else {
          betDisplay.classList.remove('visible');
        }

        // Highlight current player
        if (index === game.currentPlayerIndex && !player.folded) {
          playerInfo.classList.add('active');
        } else {
          playerInfo.classList.remove('active');
        }

        // Generate a unique render key for this hand state
        const isFaceUp = !player.folded && (!player.isHuman && game.gamePhase !== 'showdown') === false;
        const handKey = player.folded ? 'folded' :
          player.hand.map(c => c.value + c.suit).join('-') + '-' + isFaceUp;

        // Only re-render if the hand state has changed AND not currently dealing
        if (cardsContainer.dataset.renderKey !== handKey && !isDealingCards) {
          cardsContainer.dataset.renderKey = handKey;
          cardsContainer.innerHTML = '';

          // Show player's cards
          if (player.folded) {
            playerInfo.style.opacity = '0.5';
            handRankEl.textContent = 'Folded';
          } else {
            playerInfo.style.opacity = '1';

            player.hand.forEach((card) => {
              // Show human player's cards, hide AI cards unless showdown
              const showBack = !player.isHuman && game.gamePhase !== 'showdown';
              const cardEl = createCardElement(card, showBack);
              cardsContainer.appendChild(cardEl);
            });

            // Evaluate and show hand rank
            if (game.communityCards.length > 0) {
              const handEval = game.evaluateHand(player.hand, game.communityCards);
              handRankEl.textContent = handEval.name;
            } else {
              handRankEl.textContent = '';
            }
          }
        } else {
          // Even if we don't re-render cards, ensure opacity/text is correct 
          // (in case it changed without card change, though unlikely for Folded)
          if (player.folded) {
            playerInfo.style.opacity = '0.5';
            if (handRankEl.textContent !== 'Folded') handRankEl.textContent = 'Folded';
          } else {
            playerInfo.style.opacity = '1';
          }
        }

        // Update or create dealer button
        let dealerBtn = playerEl.querySelector('.dealer-button');
        if (index === game.dealerIndex) {
          if (!dealerBtn) {
            dealerBtn = document.createElement('div');
            dealerBtn.className = 'dealer-button';
            dealerBtn.textContent = 'D';
            playerEl.appendChild(dealerBtn);
          }
          dealerBtn.style.display = 'flex';
        } else if (dealerBtn) {
          dealerBtn.style.display = 'none';
        }

        // Update or create blind indicator
        let blindIndicator = playerEl.querySelector('.blind-indicator');
        if (player.isSmallBlind || player.isBigBlind) {
          if (!blindIndicator) {
            blindIndicator = document.createElement('div');
            blindIndicator.className = 'blind-indicator';
            playerInfo.appendChild(blindIndicator);
          }
          blindIndicator.textContent = player.isSmallBlind ? 'SB' : 'BB';
          blindIndicator.style.display = 'block';
        } else if (blindIndicator) {
          blindIndicator.style.display = 'none';
        }

        // Update or create all-in indicator
        let allInIndicator = playerEl.querySelector('.all-in-indicator');
        if (player.isAllIn && !player.folded) {
          if (!allInIndicator) {
            allInIndicator = document.createElement('div');
            allInIndicator.className = 'all-in-indicator';
            allInIndicator.textContent = 'ALL-IN';
            playerInfo.appendChild(allInIndicator);
          }
          allInIndicator.style.display = 'block';
        } else if (allInIndicator) {
          allInIndicator.style.display = 'none';
        }
      });

      updatePotDisplay();
      updateStatusMessage();
      updatePlayerControls();

      // Update learning features
      if (game.learningEngine) {
        game.updatePlayerEquity();
        updateEquityDisplay();
        updateOutsDisplay();
        updateAdvisorPanel();
      }
    }

    function updatePlayerControls() {
      const controls = document.getElementById('playerControls');
      const currentPlayer = game.getCurrentPlayer();

      if (game.gamePhase === 'waiting' || game.gamePhase === 'showdown') {
        controls.style.display = 'none';
        return;
      }

      if (currentPlayer.isHuman && !isProcessingAI) {
        controls.style.display = 'flex';

        // Update call button
        const callAmount = game.currentBet - currentPlayer.currentBet;
        document.getElementById('callAmount').textContent = callAmount;
        document.getElementById('callBtn').style.display = callAmount > 0 ? 'inline-block' : 'none';

        // Update check button
        document.getElementById('checkBtn').style.display = callAmount === 0 ? 'inline-block' : 'none';

        // Update minimum raise display
        const minRaiseInfo = document.getElementById('minRaiseInfo');
        const minRaiseAmount = document.getElementById('minRaiseAmount');
        const minRaise = game.lastRaiseSize || game.bigBlind;

        if (game.currentBet > 0) {
          minRaiseInfo.style.display = 'block';
          minRaiseAmount.textContent = minRaise;
        } else {
          minRaiseInfo.style.display = 'none';
        }
      } else {
        controls.style.display = 'none';
      }
    }

    let aiLockTime = 0;
    function processAITurns() {
      if (isProcessingAI) {
        // Self-healing: if stuck for > 5 seconds, reset lock
        if (Date.now() - aiLockTime > 5000) {
          console.warn("AI processing stuck, self-healing reset.");
          isProcessingAI = false;
        } else {
          return;
        }
      }

      isProcessingAI = true;
      aiLockTime = Date.now();

      function processNextAI() {
        const currentPlayer = game.getCurrentPlayer();

        // Check completion first! 
        // If betting is done, we don't care if the current player is folded/all-in/human/martian.
        if (game.isBettingComplete()) {
          isProcessingAI = false;

          if (game.gamePhase !== 'showdown') {
            // Check if further betting is possible
            const activePlayers = game.players.filter(p => !p.folded);
            const playersWithChips = activePlayers.filter(p => p.chips > 0).length;

            if (playersWithChips < 2) {
              // Auto-advance if no more betting actions possible (All-In Scenario)
              setTimeout(() => advancePhase(), 1500);
            } else {
              // Betting round complete, show next phase button
              document.getElementById('nextPhaseBtn').style.display = 'inline-block';
            }
          }
          renderGame();
          return;
        }

        // Safety: If game thinks it's a player's turn but they are folded/all-in, skip them immediately
        // This prevents getting stuck on a folded Human player
        if (currentPlayer.folded || currentPlayer.isAllIn) {
          game.advanceToNextPlayer();
          // If we looped all the way back to same state, handle via timeout to allow render/check
          setTimeout(processNextAI, 100);
          return;
        }

        if (currentPlayer.isHuman) {
          isProcessingAI = false;

          renderGame();
          return;
        }

        // AI makes decision
        // AI makes decision
        setTimeout(() => {
          try {
            game.simulateAIAction(currentPlayer.id);
          } catch (error) {
            console.error("AI Error:", error);
            // Force action to unblock game
            try {
              game.playerCheck(currentPlayer.id);
            } catch (e) {
              game.playerFold(currentPlayer.id);
            }
          }

          // Check if only one player remains after AI action
          if (game.checkForSinglePlayer()) {
            isProcessingAI = false;
            renderGame();
            setTimeout(() => showWinner(), 500);
            return;
          }

          game.advanceToNextPlayer();
          renderGame();
          aiLockTime = Date.now(); // Refresh lock
          processNextAI();
        }, 1000);
      }

      processNextAI();
    }

    // AI Heartbeat: Proactively check for stalls every 4 seconds
    setInterval(() => {
      if (game && !game.gameOver && game.gamePhase !== 'waiting' && game.gamePhase !== 'showdown') {
        const currentPlayer = game.getCurrentPlayer();
        if (currentPlayer && !currentPlayer.isHuman && !isProcessingAI) {
          // AI's turn but processing is not active? Something stalled.
          console.warn(`Heartbeat: Turn stalled on ${currentPlayer.name}. Forcing processAITurns.`);
          processAITurns();
        } else if (isProcessingAI && Date.now() - aiLockTime > 8000) {
          // AI is allegedly processing but has been locked for > 8 seconds.
          // This usually means an error occurred in the AI logic.
          console.warn("Heartbeat: AI processing locked for too long. Force-advancing turn.");
          isProcessingAI = false;
          game.advanceToNextPlayer();
          renderGame();
          processAITurns();
        }
      }
    }, 4000);


    function startNewHand() {
      game.startNewHand();

      // Check if game is over for human player
      if (game.gameOver) {
        showGameOver();
        return;
      }
      updateBankrollDisplay();

      // Animate dealing
      animateDeal();

      document.getElementById('newHandBtn').style.display = 'none';
      document.getElementById('nextPhaseBtn').style.display = 'none';
      document.getElementById('showWinnerBtn').style.display = 'none';

      // Clear all player cards from display first
      game.players.forEach((player) => {
        const playerEl = document.getElementById(`player-${player.id}`);
        if (!playerEl) return;

        if (player.eliminated) {
          playerEl.style.display = 'none';
          return;
        }

        const cardsContainer = playerEl.querySelector('.player-cards');
        cardsContainer.innerHTML = '';

        // Remove winner highlight
        const playerInfo = playerEl.querySelector('.player-info');
        if (playerInfo) {
          playerInfo.classList.remove('winner');
        }
      });

      // Deal cards one at a time like a real dealer
      dealCardsSequentially();
    }

    function dealCardsSequentially() {
      const activePlayers = game.players.filter(p => !p.folded && !p.eliminated);
      let cardIndex = 0;
      const totalCards = activePlayers.length * 2; // 2 cards per player
      isDealingCards = true;

      function dealNextCard() {
        if (cardIndex >= totalCards) {
          // All cards dealt, update display and start betting
          isDealingCards = false;
          renderGame();
          setTimeout(() => {
            processAITurns();
          }, 500);
          return;
        }

        const playerIndex = cardIndex % activePlayers.length;
        const player = activePlayers[playerIndex];
        const whichCard = Math.floor(cardIndex / activePlayers.length);

        if (player.hand[whichCard]) {
          const playerEl = document.getElementById(`player-${player.id}`);
          if (playerEl) {
            const cardsContainer = playerEl.querySelector('.player-cards');
            const cardEl = createCardElement(player.hand[whichCard], !player.isHuman);
            cardsContainer.appendChild(cardEl);
            soundManager.playCardDeal();
          }
        }

        cardIndex++;
        setTimeout(dealNextCard, 150); // 150ms delay between each card
      }

      dealNextCard();
    }


    function advancePhase() {
      if (game.gamePhase === 'preflop') {
        game.dealFlop();
      } else if (game.gamePhase === 'flop') {
        game.dealTurn();
      } else if (game.gamePhase === 'turn') {
        game.dealRiver();
      } else if (game.gamePhase === 'river') {
        game.gamePhase = 'showdown';
        showWinner();
        return;
      }

      document.getElementById('nextPhaseBtn').style.display = 'none';
      renderGame();

      setTimeout(() => {
        processAITurns();
      }, 1000);
    }

    function showWinner() {
      // Hide next phase button immediately
      document.getElementById('nextPhaseBtn').style.display = 'none';
      isProcessingAI = false;
      game.gamePhase = 'showdown';
      game.inShowdownUI = true;

      try {

        // Check if this is a single player win (everyone else folded)
        if (game.singlePlayerWin && game.singleWinner) {
          const winner = game.singleWinner;

          // Remove previous winner highlights
          document.querySelectorAll('.player-info').forEach(el => {
            el.classList.remove('winner');
          });

          const winnerEl = document.getElementById(`player-${winner.id}`);
          const playerInfo = winnerEl.querySelector('.player-info');
          playerInfo.classList.add('winner');

          renderGame();
          soundManager.playWinner();

          document.getElementById('statusMessage').innerHTML =
            `üèÜ <strong>${winner.name}</strong> wins $${game.pot} (all others folded)`;

          // Reset single player win flags
          game.singlePlayerWin = false;
          game.singleWinner = null;

          document.getElementById('newHandBtn').style.display = 'inline-block';
          return;
        }

        // Normal showdown with hand evaluation
        const winners = game.determineWinner();

        // Remove previous winner highlights
        document.querySelectorAll('.player-info').forEach(el => {
          el.classList.remove('winner');
        });

        // Calculate winnings per winner
        const winningsPerPlayer = Math.floor(game.pot / winners.length);

        winners.forEach(winner => {
          const winnerEl = document.getElementById(`player-${winner.id}`);
          const playerInfo = winnerEl.querySelector('.player-info');

          // Add winner class for visual effect
          playerInfo.classList.add('winner');
        });

        renderGame();

        // Play winner celebration sound
        soundManager.playWinner();

        // Update status message with clear winner information
        let wonMsg = "";
        if (winners.length === 1) {
          const handEval = game.evaluateHand(winners[0].hand, game.communityCards);
          const winnerCards = winners[0].hand.map(c => `${c.value}${c.suit}`).join(' ');
          wonMsg = `üèÜ <strong>${winners[0].name}</strong> wins $${game.pot} with <strong>${handEval.name}</strong>!<br>` +
            `<span style="font-size: 0.9em; opacity: 0.9;">Cards: ${winnerCards}</span>`;
        } else {
          const handEval = game.evaluateHand(winners[0].hand, game.communityCards);
          const winnerNames = winners.map(w => w.name).join(', ');
          wonMsg = `üèÜ <strong>Tie!</strong> ${winnerNames} split $${game.pot}<br>` +
            `<span style="font-size: 0.9em; opacity: 0.9;">Both with ${handEval.name}</span>`;
        }

        document.getElementById('statusMessage').innerHTML = wonMsg;
        // Mark as showdown specifically to prevent renderGame from overwriting status
        game.inShowdownUI = true;

        document.getElementById('newHandBtn').style.display = 'inline-block';
      } catch (err) {
        console.error("Critical Showdown Error:", err);
        // Fallback message that's less confusing
        if (!document.getElementById('statusMessage').innerHTML.includes('wins')) {
          document.getElementById('statusMessage').textContent = "Hand Over. Winner Awarded.";
        }
        document.getElementById('newHandBtn').style.display = 'inline-block';
      }
    }

    function showGameOver() {
      const modal = document.getElementById('gameOverModal');
      const titleEl = document.getElementById('gameOverTitle');
      const placementEl = document.getElementById('placementDisplay');
      const statsEl = document.getElementById('gameStats');

      // Determine placement suffix (1st, 2nd, 3rd, etc.)
      const placement = game.humanPlayerPlacement;
      let suffix = 'th';
      if (placement === 1) suffix = 'st';
      else if (placement === 2) suffix = 'nd';
      else if (placement === 3) suffix = 'rd';

      // Update title based on placement
      if (placement === 1) {
        titleEl.textContent = 'üèÜ Victory!';
        titleEl.style.color = '#ffd700';
      } else {
        titleEl.textContent = 'üíî Game Over';
        titleEl.style.color = '#fff';
      }

      // Display placement
      placementEl.innerHTML = `
        <div class="placement-number">${placement}${suffix}</div>
        <div class="placement-text">Place</div>
      `;

      // Display stats
      const totalPlayers = 9;
      const playersEliminated = game.eliminationOrder.length;
      statsEl.innerHTML = `
        <div class="stat-item">
          <span class="stat-label">Total Players:</span>
          <span class="stat-value">${totalPlayers}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Players Eliminated:</span>
          <span class="stat-value">${playersEliminated}</span>
        </div>
      `;

      // Show modal
      modal.style.display = 'flex';
      soundManager.playWinner();
    }

    function resetGame() {
      // Hide modal
      document.getElementById('gameOverModal').style.display = 'none';

      // Reset game state
      game.gameOver = false;
      game.humanPlayerPlacement = null;
      game.eliminationOrder = [];

      // Re-initialize players
      game.initializePlayers();
      game.dealerIndex = 0;
      game.gamePhase = 'waiting';

      // Reset UI
      renderGame();
      document.getElementById('newHandBtn').style.display = 'inline-block';
      document.getElementById('statusMessage').textContent = 'Click "New Hand" to start playing!';
    }

    // Player action handlers
    document.getElementById('foldBtn').addEventListener('click', () => {
      soundManager.playFold();
      game.playerFold(0);

      // Check if only one player remains
      if (game.checkForSinglePlayer()) {
        renderGame();
        setTimeout(() => showWinner(), 500);
        return;
      }

      game.advanceToNextPlayer();
      renderGame();
      processAITurns();
    });

    document.getElementById('checkBtn').addEventListener('click', () => {
      if (game.playerCheck(0)) {
        soundManager.playCheck();

        // Check if only one player remains
        if (game.checkForSinglePlayer()) {
          renderGame();
          setTimeout(() => showWinner(), 500);
          return;
        }

        game.advanceToNextPlayer();
        renderGame();
        processAITurns();
      }
    });

    document.getElementById('callBtn').addEventListener('click', () => {
      if (game.playerCall(0)) {
        soundManager.playChipSound();

        // Check if only one player remains
        if (game.checkForSinglePlayer()) {
          renderGame();
          setTimeout(() => showWinner(), 500);
          return;
        }

        game.advanceToNextPlayer();
        renderGame();
        processAITurns();
      }
    });

    document.getElementById('betBtn').addEventListener('click', () => {
      const amount = parseInt(document.getElementById('betAmount').value);
      if (game.playerBet(0, amount)) {
        soundManager.playChipSound();

        // Check if only one player remains
        if (game.checkForSinglePlayer()) {
          renderGame();
          setTimeout(() => showWinner(), 500);
          return;
        }

        game.advanceToNextPlayer();
        renderGame();
        processAITurns();
      }
    });

    document.getElementById('raiseBtn').addEventListener('click', () => {
      const amount = parseInt(document.getElementById('betAmount').value);
      if (game.playerRaise(0, amount)) {
        soundManager.playRaise();

        // Check if only one player remains
        if (game.checkForSinglePlayer()) {
          renderGame();
          setTimeout(() => showWinner(), 500);
          return;
        }

        game.advanceToNextPlayer();
        renderGame();
        processAITurns();
      }
    });

    // Game control handlers
    document.getElementById('newHandBtn').addEventListener('click', () => {
      soundManager.playClick();
      startNewHand();
    });
    document.getElementById('nextPhaseBtn').addEventListener('click', () => {
      soundManager.playClick();
      advancePhase();
    });
    document.getElementById('showWinnerBtn').addEventListener('click', () => {
      soundManager.playClick();
      showWinner();
    });
    document.getElementById('playAgainBtn').addEventListener('click', () => {
      soundManager.playClick();
      resetGame();
    });

    // Sound toggle handler
    document.getElementById('soundToggle').addEventListener('click', () => {
      const isMuted = soundManager.toggleMute();
      const toggleBtn = document.getElementById('soundToggle');
      if (isMuted) {
        toggleBtn.classList.add('muted');
      } else {
        toggleBtn.classList.remove('muted');
        soundManager.playClick();
      }
    });

    // Animation Functions
    function animateBet(playerId, amount) {
      if (amount <= 0) return;

      const playerEl = document.getElementById(`player-${playerId}`);
      if (!playerEl) return;

      const startRect = playerEl.getBoundingClientRect();
      const potEl = document.querySelector('.pot-display');
      const endRect = potEl.getBoundingClientRect();

      // Create flying chip
      const chip = document.createElement('div');
      chip.className = 'flying-chip';
      chip.textContent = '$' + amount;
      chip.style.left = (startRect.left + startRect.width / 2 - 15) + 'px';
      chip.style.top = (startRect.top + startRect.height / 2 - 15) + 'px';

      // Calculate travel distance
      const tx = (endRect.left + endRect.width / 2) - (startRect.left + startRect.width / 2);
      const ty = (endRect.top + endRect.height / 2) - (startRect.top + startRect.height / 2);

      chip.style.setProperty('--tx', tx + 'px');
      chip.style.setProperty('--ty', ty + 'px');

      document.body.appendChild(chip);

      // Animate
      chip.style.animation = 'flyToPot 0.6s ease-in forwards';

      // Cleanup
      setTimeout(() => {
        if (chip.parentNode) chip.parentNode.removeChild(chip);
      }, 600);
    }

    function animateDeal() {
      const players = game.players;
      const communityCardsEl = document.getElementById('communityCards');
      const centerRect = communityCardsEl.getBoundingClientRect();

      // Total cards to deal = 2 * active players
      let delay = 0;

      players.forEach((player, i) => {
        if (player.chips > 0) { // Deal to active players
          const playerEl = document.getElementById(`player-${player.id}`);
          const targetRect = playerEl.getBoundingClientRect();

          // Create card 1
          spawnCard(centerRect, targetRect, delay);
          delay += 100;
          // Create card 2
          spawnCard(centerRect, targetRect, delay);
          delay += 100;
        }
      });
    }

    function spawnCard(startRect, endRect, delay) {
      setTimeout(() => {
        const card = document.createElement('div');
        card.className = 'card dealing-card';
        card.style.left = (startRect.left + startRect.width / 2) + 'px';
        card.style.top = (startRect.top + startRect.height / 2) + 'px';
        card.style.setProperty('--end-left', (endRect.left + endRect.width / 2) + 'px');
        card.style.setProperty('--end-top', (endRect.top + endRect.height / 2) + 'px');
        card.style.animation = 'dealCard 0.5s ease-out forwards';

        document.body.appendChild(card);
        setTimeout(() => {
          if (card.parentNode) card.parentNode.removeChild(card);
        }, 500);
      }, delay);
    }

    // Initialize on load
    window.addEventListener('load', () => {
      game = new PokerGame();

      // Bind UI Callback
      game.onAction = (playerId, type, amount) => {
        // Log action
        game.logAction(playerId, type, amount);

        if (type === 'bet' || type === 'call' || type === 'raise') {
          animateBet(playerId, amount);
        }
      };

      // Display version
      if (document.getElementById('versionDisplay')) {
        document.getElementById('versionDisplay').textContent = 'v' + game.version;
      }

      game.initializeLearningEngine();

      // Update Bankroll Display
      updateBankrollDisplay();

      renderGame();
      updateDecisionFlow();
    });

    function updateDecisionFlow() {
      const flowContainer = document.getElementById('decisionFlow');
      const player = game.players[0];
      const phase = game.gamePhase;
      const isMyTurn = game.getCurrentPlayer().isHuman && phase !== 'waiting' && phase !== 'showdown';

      // Reset all steps
      document.querySelectorAll('.flow-step').forEach(s => s.className = 'flow-step');

      if (phase === 'waiting' || phase === 'showdown') {
        document.getElementById('flow-pos-desc').textContent = 'Next hand...';
        return;
      }

      // 1. Position Step
      const pos = game.getPlayerPosition(0);
      const posStep = document.getElementById('step-position');
      document.getElementById('flow-pos-desc').textContent = `In ${pos.toUpperCase()} position`;
      posStep.classList.add('step-complete');

      // 2. Preflop / Strength Step
      const preflopStep = document.getElementById('step-preflop');
      if (phase === 'preflop') {
        preflopStep.classList.add('step-active');
        document.getElementById('flow-preflop-desc').textContent = 'Consult GTO Charts';
      } else {
        preflopStep.classList.add('step-complete');
        document.getElementById('flow-preflop-desc').textContent = 'Hand locked';
      }

      // 3. Math Step (Postflop)
      const mathStep = document.getElementById('step-math');
      if (phase !== 'preflop' && phase !== 'showdown') {
        const callAmount = game.currentBet - player.currentBet;
        const potOdds = callAmount > 0 ? (callAmount / (game.pot + callAmount) * 100).toFixed(1) : 0;
        const equity = (player.equity * 100).toFixed(1);

        document.getElementById('flow-math-desc').textContent = `${equity}% EQ vs ${potOdds}% Odds`;

        if (isMyTurn) mathStep.classList.add('step-active');
        else mathStep.classList.add('step-complete');
      } else {
        document.getElementById('flow-math-desc').textContent = 'Awaiting flop...';
      }

      // 4. Final Decision Step
      const decisionStep = document.getElementById('step-decision');
      if (isMyTurn) {
        decisionStep.classList.add('step-active');
        const rec = game.getOptimalActionForPlayer();
        document.getElementById('flow-decision-desc').textContent = rec ? `Rec: ${rec.action.toUpperCase()}` : 'Thinking...';
      } else {
        document.getElementById('flow-decision-desc').textContent = 'Waiting for turn';
      }
    }

    function updateBankrollDisplay() {
      if (game && game.bankrollManager) {
        const amount = game.bankrollManager.data.bankroll.toFixed(0);
        document.getElementById('bankrollValue').textContent = '$' + amount;
      }
    }

    // Coach mode toggle handler
    document.getElementById('coachToggle').addEventListener('click', () => {
      game.settings.enableCoachMode = !game.settings.enableCoachMode;
      const toggleBtn = document.getElementById('coachToggle');
      if (game.settings.enableCoachMode) {
        toggleBtn.classList.add('active');
      } else {
        toggleBtn.classList.remove('active');
      }
      updateEquityDisplay();
      updateOutsDisplay();
      updateAdvisorPanel();
      soundManager.playClick();
    });

    // Update equity display
    function updateEquityDisplay() {
      const equityDisplay = document.getElementById('equityDisplay');
      const player = game.players[0];

      if (!game.settings.enableCoachMode || game.gamePhase === 'waiting' || player.folded) {
        equityDisplay.style.display = 'none';
        return;
      }

      if (player.hand.length === 2) {
        equityDisplay.style.display = 'block';
        const equityPercent = (player.equity * 100).toFixed(1);
        document.getElementById('equityText').textContent = `${equityPercent}%`;
        document.getElementById('equityFill').style.width = `${equityPercent}%`;

        // Update pot odds indicator
        const callAmount = game.currentBet - player.currentBet;
        const potOdds = callAmount > 0 ? callAmount / (game.pot + callAmount) : 0;
        const indicator = document.getElementById('potOddsIndicator');

        if (callAmount > 0) {
          if (player.equity > potOdds) {
            indicator.textContent = '‚úì Good pot odds';
            indicator.className = 'pot-odds-indicator good';
          } else {
            indicator.textContent = '‚úó Poor pot odds';
            indicator.className = 'pot-odds-indicator bad';
          }
          indicator.style.display = 'block';
        } else {
          indicator.style.display = 'none';
        }
      } else {
        equityDisplay.style.display = 'none';
      }
    }

    // Update outs display
    function updateOutsDisplay() {
      const outsDisplay = document.getElementById('outsDisplay');
      const player = game.players[0];

      if (!game.settings.enableCoachMode || game.gamePhase === 'waiting' ||
        player.folded || !game.learningEngine || game.communityCards.length < 3) {
        outsDisplay.style.display = 'none';
        return;
      }

      if (player.hand.length === 2 && game.communityCards.length >= 3 && game.communityCards.length < 5) {
        outsDisplay.style.display = 'block';

        // Calculate outs
        const outsData = game.learningEngine.calculateOuts(player.hand, game.communityCards);

        // Display total outs
        document.getElementById('outsTotal').textContent = `${outsData.total} outs`;

        // Display breakdown
        const breakdownEl = document.getElementById('outsBreakdown');
        if (Object.keys(outsData.breakdown).length > 0) {
          let breakdownHTML = '<div class="outs-breakdown-title">Breakdown:</div>';
          for (const [type, count] of Object.entries(outsData.breakdown)) {
            breakdownHTML += `<div class="out-type">${type}: ${count}</div>`;
          }
          breakdownEl.innerHTML = breakdownHTML;
        } else {
          breakdownEl.innerHTML = '<div class="no-outs">No improving outs detected</div>';
        }

        // Rule of 2 and 4
        const street = game.communityCards.length === 3 ? 'flop' : 'turn';
        const rulePercent = game.learningEngine.getRuleOf2And4(outsData.total, street);
        const ruleEl = document.getElementById('ruleOf24');
        if (outsData.total > 0) {
          ruleEl.innerHTML = `<strong>Rule of ${street === 'flop' ? '4' : '2'}:</strong> ~${rulePercent}% to improve`;
        } else {
          ruleEl.innerHTML = '';
        }

        // Implied odds
        const callAmount = game.currentBet - player.currentBet;
        if (callAmount > 0 && outsData.total > 0) {
          const maxOpponentStack = Math.max(...game.players.filter(p => !p.folded && p.id !== 0).map(p => p.chips));
          const impliedOdds = game.learningEngine.calculateImpliedOdds(
            game.pot, callAmount, player.chips, maxOpponentStack, outsData.total
          );
          const impliedEl = document.getElementById('impliedOdds');
          impliedEl.innerHTML = `<strong>Implied Odds:</strong> ${(impliedOdds * 100).toFixed(1)}%`;
        } else {
          document.getElementById('impliedOdds').innerHTML = '';
        }

        // Clean vs Dirty outs
        if (outsData.total > 0) {
          const classification = game.learningEngine.classifyOuts(outsData, game.communityCards);
          const classEl = document.getElementById('outsClassification');
          if (classification.explanation.length > 0) {
            let classHTML = '<div class="outs-class-title">Classification:</div>';
            classification.explanation.forEach(exp => {
              const isDirty = exp.includes('dirty');
              classHTML += `<div class="out-classification ${isDirty ? 'dirty' : 'clean'}">${exp}</div>`;
            });
            classEl.innerHTML = classHTML;
          }
        }
      } else {
        outsDisplay.style.display = 'none';
      }
    }

    // Update advisor panel
    function updateAdvisorPanel() {
      const advisorPanel = document.getElementById('advisorPanel');
      const player = game.players[0];

      if (!game.settings.enableCoachMode || game.gamePhase === 'waiting' ||
        player.folded || !game.getCurrentPlayer().isHuman) {
        advisorPanel.style.display = 'none';
        return;
      }

      const recommendation = game.getOptimalActionForPlayer();
      if (!recommendation) {
        advisorPanel.style.display = 'none';
        return;
      }

      advisorPanel.style.display = 'block';

      // Update action
      const actionEl = document.getElementById('advisorAction');
      actionEl.textContent = recommendation.action.toUpperCase();
      actionEl.className = 'advisor-action ' + recommendation.action.toLowerCase();

      // Update confidence
      document.getElementById('advisorConfidence').textContent =
        `Confidence: ${recommendation.confidence}`;

      // Generate and display explanation
      const callAmount = game.currentBet - player.currentBet;
      const position = game.getPlayerPosition(0);
      const explanation = game.learningEngine.generateExplanation(
        recommendation, player.hand, game.communityCards, game.pot, callAmount, position
      );
      document.getElementById('advisorExplanation').textContent = explanation;

      // Show alternative actions with EV
      const alternatives = document.getElementById('advisorAlternatives');
      let altHTML = '<div class="ev-comparison">Expected Value:</div>';
      for (const [action, ev] of Object.entries(recommendation.ev)) {
        if (ev !== null) {
          const evValue = ev.toFixed(2);
          const isBest = action === recommendation.action;
          altHTML += `<div class="ev-item ${isBest ? 'best' : ''}">${action.toUpperCase()}: $${evValue}</div>`;
        }
      }
      alternatives.innerHTML = altHTML;
    }

    // Show equity calculation explanation
    function showEquityExplanation() {
      const modal = document.getElementById('explanationModal');
      const title = document.getElementById('explanationTitle');
      const body = document.getElementById('explanationBody');

      title.textContent = 'üéØ How is Equity Calculated?';

      const player = game.players[0];
      const numOpponents = game.players.filter(p => !p.folded).length - 1;

      body.innerHTML = `
        <h3>Monte Carlo Simulation</h3>
        <p>Equity is calculated using a <strong>Monte Carlo simulation</strong>, which runs hundreds of random scenarios to determine your winning probability.</p>
        
        <h3>The Process</h3>
        <ul>
          <li><strong>Step 1:</strong> Take your current hand and the community cards</li>
          <li><strong>Step 2:</strong> Deal random cards to ${numOpponents} opponent${numOpponents !== 1 ? 's' : ''}</li>
          <li><strong>Step 3:</strong> Complete the board with random community cards</li>
          <li><strong>Step 4:</strong> Determine the winner</li>
          <li><strong>Step 5:</strong> Repeat this process <code>500 times</code></li>
        </ul>
        
        <h3>Calculating Your Equity</h3>
        <p>After running all simulations:</p>
        <p><code>Equity = (Wins + Ties/2) / Total Simulations</code></p>
        
        <h3>Current Hand</h3>
        <p>Your equity: <strong>${player.equity ? (player.equity * 100).toFixed(1) : 'N/A'}%</strong></p>
        <p>This means you win approximately <strong>${player.equity ? (player.equity * 100).toFixed(1) : 'N/A'}</strong> out of 100 times with this hand against ${numOpponents} opponent${numOpponents !== 1 ? 's' : ''}.</p>
        
        <h3>Why It Matters</h3>
        <p>Equity helps you understand your <strong>true winning chances</strong>, which is essential for making profitable decisions. Compare your equity to pot odds to determine if calling is mathematically correct.</p>
      `;

      modal.style.display = 'flex';
      if (window.soundManager) soundManager.playClick();
    }

    // Show EV calculation explanation
    function showEVExplanation() {
      const modal = document.getElementById('explanationModal');
      const title = document.getElementById('explanationTitle');
      const body = document.getElementById('explanationBody');

      title.textContent = 'üí∞ How is Expected Value (EV) Calculated?';

      const player = game.players[0];
      const callAmount = game.currentBet - player.currentBet;
      const potAfterCall = game.pot + callAmount;
      const equity = player.equity || 0.5;

      body.innerHTML = `
        <h3>Expected Value Formula</h3>
        <p>EV measures the average profit or loss of a decision over the long run:</p>
        <p><code>EV = (Win Probability √ó Pot) - (Loss Probability √ó Cost)</code></p>
        
        <h3>For Each Action</h3>
        
        <p><strong>FOLD:</strong></p>
        <p><code>EV = $0</code> (you lose nothing, win nothing)</p>
        
        <p><strong>CALL:</strong></p>
        <p><code>EV = (${(equity * 100).toFixed(1)}% √ó $${potAfterCall}) - (${((1 - equity) * 100).toFixed(1)}% √ó $${callAmount})</code></p>
        <p><code>EV = $${(equity * potAfterCall - (1 - equity) * callAmount).toFixed(2)}</code></p>
        
        <p><strong>RAISE:</strong></p>
        <p>Raising adds fold equity (chance opponents fold) and increases the pot when you win. The calculation considers:</p>
        <ul>
          <li>Probability opponents fold</li>
          <li>Your equity when called</li>
          <li>The size of the raise</li>
        </ul>
        
        <h3>Interpreting EV</h3>
        <ul>
          <li><strong>Positive EV (+$X):</strong> Profitable long-term decision</li>
          <li><strong>Negative EV (-$X):</strong> Losing decision over time</li>
          <li><strong>Zero EV ($0):</strong> Break-even play</li>
        </ul>
        
        <h3>The Best Action</h3>
        <p>The coach recommends the action with the <strong>highest EV</strong>. Even if an action has negative EV, it might be the best choice if all alternatives are worse (like folding vs. calling with pot odds).</p>
        
        <h3>Why It Matters</h3>
        <p>Consistently making <strong>+EV decisions</strong> is the key to long-term poker profitability. Even if you lose individual hands, positive EV plays will make you money over thousands of hands.</p>
      `;

      modal.style.display = 'flex';
      if (window.soundManager) soundManager.playClick();
    }

    // Close explanation modal
    function closeExplanation() {
      document.getElementById('explanationModal').style.display = 'none';
      if (window.soundManager) soundManager.playClick();
    }

    // Event listeners for info buttons
    document.getElementById('equityInfoBtn').addEventListener('click', showEquityExplanation);
    document.getElementById('evInfoBtn').addEventListener('click', showEVExplanation);
    document.getElementById('explanationClose').addEventListener('click', closeExplanation);

    // Close modal when clicking outside
    document.getElementById('explanationModal').addEventListener('click', (e) => {
      if (e.target.id === 'explanationModal') {
        closeExplanation();
      }
    });
    // History UI Functions


    function renderHistoryList() {
      const listEl = document.getElementById('historyList');
      const detailEl = document.getElementById('historyDetail');

      listEl.style.display = 'block';
      detailEl.style.display = 'none';

      if (!game.handHistory || game.handHistory.length === 0) {
        listEl.innerHTML = '<p>No hands played yet.</p>';
        return;
      }

      let html = '<ul class="history-ul">';
      // Show newest first
      [...game.handHistory].reverse().forEach(hand => {
        const time = hand.startTime;
        const pot = hand.pot || 0;
        // Try to find if user won or lost
        // logic depends on if log has winner info. 
        // For now just show Time + cards
        const holeCards = hand.holeCards ? hand.holeCards.join(' ') : '??';

        html += `
                <li onclick="showHandDetail(${hand.id})" class="history-item">
                    <span class="history-time">${time}</span>
                    <span class="history-cards">${holeCards}</span>
                    <span class="history-pot">Pot: $${pot}</span>
                </li>
            `;
      });
      html += '</ul>';
      listEl.innerHTML = html;
    }

    function showHandDetail(handId) {
      const hand = game.handHistory.find(h => h.id === handId);
      if (!hand) return;

      const listEl = document.getElementById('historyList');
      const detailEl = document.getElementById('historyDetail');
      const contentEl = document.getElementById('detailContent');

      listEl.style.display = 'none';
      detailEl.style.display = 'block';

      let actionsHtml = '<table class="history-table"><tr><th>Stage</th><th>Player</th><th>Action</th><th>Amount</th></tr>';
      hand.actions.forEach(act => {
        actionsHtml += `
                <tr>
                    <td>${act.stage}</td>
                    <td>${act.actor}</td>
                    <td>${act.action}</td>
                    <td>${act.amount > 0 ? '$' + act.amount : '-'}</td>
                </tr>
             `;
      });
      actionsHtml += '</table>';

      const community = hand.communityCards ?
        hand.communityCards.map(c => c.value + c.suit).join(' ') : 'None';

      contentEl.innerHTML = `
            <h3>${hand.startTime}</h3>
            <div class="history-summary">
                <p><strong>Your Hand:</strong> ${hand.holeCards.join(' ')}</p>
                <p><strong>Board:</strong> ${community}</p>
                <p><strong>Total Pot:</strong> $${hand.pot || 0}</p>
            </div>
            <h4>Action Log</h4>
            ${actionsHtml}
        `;
    }

    function backToHistoryList() {
      document.getElementById('historyList').style.display = 'block';
      document.getElementById('historyDetail').style.display = 'none';
    }

    // ANALYTICS UI


    function updateAnalyticsUI() {
      if (!game || !game.userStats) return;

      const stats = game.userStats;
      const hands = stats.handsDealt || 0;

      if (hands === 0) return;

      // VPIP
      const vpip = Math.round((stats.vpipCount / hands) * 100);
      document.getElementById('vpipValue').textContent = vpip + '%';
      let vAdvice = "Optimal";
      if (vpip < 15) vAdvice = "Too Tight (Nit)";
      if (vpip > 35) vAdvice = "Too Loose (Fish)";
      document.getElementById('vpipAdvice').textContent = vAdvice;
      document.getElementById('vpipAdvice').className =
        'stat-advice ' + (vpip >= 15 && vpip <= 35 ? 'good' : 'bad');

      // PFR
      const pfr = Math.round((stats.pfrCount / hands) * 100);
      document.getElementById('pfrValue').textContent = pfr + '%';
      let pAdvice = "Optimal";
      if (pfr < 10) pAdvice = "Too Passive";
      if (pfr > 30) pAdvice = "Too Aggressive";
      document.getElementById('pfrAdvice').textContent = pAdvice;
      document.getElementById('pfrAdvice').className =
        'stat-advice ' + (pfr >= 10 && pfr <= 30 ? 'good' : 'bad');

      // Aggression (Bets / (Bets+Calls))
      const totalActions = stats.aggressionCount + stats.passiveCount;
      let agg = 0;
      if (totalActions > 0) {
        agg = Math.round((stats.aggressionCount / totalActions) * 100);
      }
      document.getElementById('aggValue').textContent = agg + '%';
      let aAdvice = "Optimal";
      if (agg < 20) aAdvice = "Calling Station";
      if (agg > 60) aAdvice = "Maniac";
      document.getElementById('aggAdvice').textContent = aAdvice;
      document.getElementById('aggAdvice').className =
        'stat-advice ' + (agg >= 20 && agg <= 60 ? 'good' : 'bad');
    }

    // DRILLS UI


    function startDrill(type) {
      if (!game) return;
      game.startScenario(type);
      renderGame();
      toggleDrills();

      // Show Drill Started Msg
      const msg = document.getElementById('statusMessage');
      msg.textContent = "Drill Started! Good Luck.";
      msg.style.color = "#ffd700";
    }

    // CHARTS UI
    function toggleCharts() {
      const modal = document.getElementById('chartsModal');
      modal.style.display = (modal.style.display === 'block') ? 'none' : 'block';
    }

    let preflopCharts = null;
    function updateChart(pos) {
      if (!preflopCharts) preflopCharts = new PreflopCharts();

      const display = document.getElementById('chartDisplay');
      let html = `<h3>${pos} Strategy</h3>`;
      html += `<div class="chart-row premium"><strong>Premium (AA,KK,AK):</strong> ${preflopCharts.getAction(pos, 'premium')}</div>`;
      html += `<div class="chart-row strong"><strong>Strong (JJ,TT,AQ):</strong> ${preflopCharts.getAction(pos, 'strong')}</div>`;
      html += `<div class="chart-row playable"><strong>Playable (88,ATs):</strong> ${preflopCharts.getAction(pos, 'playable')}</div>`;
      html += `<div class="chart-row speculative"><strong>Speculative (Suited Connectors):</strong> ${preflopCharts.getAction(pos, 'speculative')}</div>`;

      display.innerHTML = html;

      // Highlight active btn
      document.querySelectorAll('.pos-btn').forEach(b => b.classList.remove('active'));
      event.target.classList.add('active');
    }

    // MATH DOJO UI
    let mathStreak = 0;
    let currentMathEquity = 0;

    function toggleMath() {
      const modal = document.getElementById('mathModal');
      if (modal.style.display === 'block') {
        modal.style.display = 'none';
      } else {
        modal.style.display = 'block';
        nextMathQuestion();
      }
    }

    function nextMathQuestion() {
      document.getElementById('quizResult').textContent = '';

      // Generate Random Hand
      const deck = new PokerGame().deck; // Get a fresh deck structure (hacky but works if Game logic permits partial use)
      // Actually simpler: Just pick random cards
      const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
      const values = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2'];
      const getCard = () => {
        const s = suits[Math.floor(Math.random() * 4)];
        const v = values[Math.floor(Math.random() * 13)];
        return { value: v, suit: s, color: (s === '‚ô•' || s === '‚ô¶') ? 'red' : 'black' };
      };

      const hand = [getCard(), getCard()];
      // Ensure unique... logic skipped for brevity/speed, chances low collision
      const board = [getCard(), getCard(), getCard()];

      // Render
      const handHtml = hand.map(c => `<div class="card ${c.color}">${c.value}${c.suit}</div>`).join('');
      const boardHtml = board.map(c => `<div class="card ${c.color}">${c.value}${c.suit}</div>`).join('');

      document.getElementById('quizHand').innerHTML = handHtml;
      document.getElementById('quizBoard').innerHTML = boardHtml;

      // Calculate Equity
      if (game && game.learningEngine) {
        // Need numeric values
        const fix = (c) => ({ ...c, numericValue: game.getNumericValue(c.value) });
        const h = hand.map(fix);
        const b = board.map(fix);
        currentMathEquity = game.learningEngine.calculateEquity(h, b, 1, 500).equity * 100;
      }
    }

    function checkMathAnswer(min) {
      const max = min + 20;
      const resultDiv = document.getElementById('quizResult');

      if (currentMathEquity >= min && currentMathEquity <= max) {
        mathStreak++;
        resultDiv.textContent = `Correct! Exact: ${currentMathEquity.toFixed(1)}%`;
        resultDiv.style.color = '#4CAF50';
        playSound('chip-bet'); // Reward sound
      } else {
        mathStreak = 0;
        resultDiv.textContent = `Wrong. Exact: ${currentMathEquity.toFixed(1)}%`;
        resultDiv.style.color = '#ff5252';
      }
      document.getElementById('mathStreak').textContent = mathStreak;
    }
    // RANGE VISUALIZER UI
    function toggleRanges() {
      const modal = document.getElementById('rangeModal');
      if (modal.style.display === 'block') {
        modal.style.display = 'none';
      } else {
        renderRangeGrid();
        modal.style.display = 'block';
      }
    }
    // Modals visibility helper
    function toggleModal(modalId) {
      const modal = document.getElementById(modalId);
      if (!modal) return;

      const isVisible = modal.classList.contains('visible');

      // Close all other modals first
      document.querySelectorAll('.modal').forEach(m => m.classList.remove('visible'));

      if (!isVisible) {
        modal.classList.add('visible');
        if (modalId === 'rangeModal') renderRangeGrid();
        if (modalId === 'historyModal') renderHistoryList();
        if (modalId === 'analyticsModal') updateAnalyticsUI();
        if (modalId === 'mathModal') nextMathQuestion();
      }

      if (window.soundManager) soundManager.playClick();
    }

    function toggleHistory() { toggleModal('historyModal'); }
    function toggleAnalytics() { toggleModal('analyticsModal'); }
    function toggleDrills() { toggleModal('drillsModal'); }
    function toggleRanges() { toggleModal('rangeModal'); }
    function toggleCharts() { toggleModal('chartsModal'); }
    function toggleMath() { toggleModal('mathModal'); }

    function togglePositionGuide(id = 'positionGuide') {
      const guide = document.getElementById(id);
      if (!guide) return;
      if (guide.style.display === 'none') {
        guide.style.display = 'flex';
        if (window.soundManager) soundManager.playClick();
      } else {
        guide.style.display = 'none';
      }
    }

    function renderRangeGrid() {
      if (!game || !game.learningEngine || !game.rangeCalculator) return;
      const gridData = game.rangeCalculator.getRangeGrid();
      const container = document.getElementById('rangeGrid');

      container.innerHTML = '';

      gridData.forEach(cell => {
        const div = document.createElement('div');
        div.className = 'range-cell';
        div.textContent = cell.label;

        // Color logic
        const w = cell.weight;
        if (w > 0.8) div.classList.add('range-100');
        else if (w > 0.4) div.classList.add('range-50');
        else if (w > 0.1) div.classList.add('range-20');
        else div.classList.add('range-0');

        div.title = `${cell.label} (${Math.round(w * 100)}%)`;
        container.appendChild(div);
      });
    }

    // TRAINING FORM LOGIC
    let currentTrainingStep = null;

    function showTrainingForm(stepId) {
      currentTrainingStep = stepId;
      const modal = document.getElementById('trainingModal');
      const title = document.getElementById('trainingTitle');
      const body = document.getElementById('trainingFormBody');
      const feedback = document.getElementById('trainingFeedback');

      feedback.className = 'feedback-area';
      feedback.style.display = 'none';

      let html = '';
      if (stepId === 'position') {
        title.textContent = 'üìç Seat Identification';
        html = `
          <div class="form-group">
            <label>What is your current table position?</label>
            <div class="training-options">
              <div class="training-option" onclick="selectTrainingOption(this, 'early')">Early (SB/BB/UTG)</div>
              <div class="training-option" onclick="selectTrainingOption(this, 'middle')">Middle (MP/HJ)</div>
              <div class="training-option" onclick="selectTrainingOption(this, 'late')">Late (CO/BTN)</div>
              <div class="training-option" onclick="selectTrainingOption(this, 'dealer')">Dealer</div>
            </div>
            <button class="btn btn-secondary" style="margin-top: 15px; width: 100%; border: 1px dashed var(--gold); background: rgba(255, 215, 0, 0.1);" onclick="togglePositionGuide('trainingPositionGuide')">
              üìñ View Position Guide
            </button>
            <div id="trainingPositionGuide" class="position-guide" style="display: none;">
              <div class="guide-item">
                <strong>üìç UTG (Under the Gun):</strong> First to act. You are "under pressure" and need very strong hands.
              </div>
              <div class="guide-item">
                <strong>üìç HJ (Hijack) / MP:</strong> Middle seats. More flexibility than UTG.
              </div>
              <div class="guide-item">
                <strong>üìç Late / CO (Cutoff):</strong> Just before the Button. Great for "cutting off" the blinds.
              </div>
              <div class="guide-item">
                <strong>üìç Dealer / BTN:</strong> The best seat. You act last on every street!
              </div>
              <div class="guide-item">
                <strong>üìç SB (Small Blind):</strong> Act first post-flop (Out of Position).
              </div>
              <div class="guide-item">
                <strong>üìç BB (Big Blind):</strong> Full-blind. Last to act preflop.
              </div>
            </div>
          </div>
        `;
      } else if (stepId === 'preflop') {
        title.textContent = 'üÉè Range Analysis';
        html = `
          <div class="form-group">
            <p style="font-size: 0.8em; color: #888; margin-bottom: 15px;">
              üéì <strong>GTO:</strong> Game Theory Optimal strategy. Mathematically perfect play that cannot be exploited.
            </p>
            <label>Categorize your Hole Cards:</label>
            <div class="training-options">
              <div class="training-option" onclick="selectTrainingOption(this, 'premium')">Premium (AA-TT, AK)</div>
              <div class="training-option" onclick="selectTrainingOption(this, 'strong')">Strong (AQ, AJ, KQ)</div>
              <div class="training-option" onclick="selectTrainingOption(this, 'playable')">Playable (Pairs, Suited)</div>
              <div class="training-option" onclick="selectTrainingOption(this, 'junk')">Junk / Trash</div>
            </div>
            <button class="btn btn-secondary" style="margin-top: 15px; width: 100%; border: 1px dashed var(--gold); background: rgba(255, 215, 0, 0.1);" onclick="toggleCharts()">
              üìä View GTO Chart
            </button>
          </div>
        `;
      } else if (stepId === 'math') {
        title.textContent = 'üìä Math Analysis';
        html = `
          <div class="form-group">
            <p style="font-size: 0.8em; color: #888; margin-bottom: 15px;">
              ‚ö†Ô∏è <strong>Note:</strong> Mathematical analysis of outs and equity is for <strong>post-flop</strong> play.
            </p>
            <label>Estimated OUTS (0-21):</label>
            <input type="number" id="train-outs" class="btn btn-secondary" style="background:#222; width:100px;">
          </div>
          <div class="form-group">
            <label>Estimated EQUITY (%):</label>
            <input type="number" id="train-equity" class="btn btn-secondary" style="background:#222; width:100px;">
          </div>
          <div class="form-group">
            <label>Pot Odds / Required Equity (%):</label>
            <input type="number" id="train-pot-odds" class="btn btn-secondary" style="background:#222; width:100px;">
            <p style="font-size: 0.7em; color: #666; margin-top: 5px;">
              üí° <em>Hint: Call / (Pot + Call)</em>
            </p>
          </div>
        `;
      } else if (stepId === 'decision') {
        title.textContent = '‚ö° Final Decision';
        html = `
          <div class="form-group">
            <label>What is the best move here?</label>
            <div class="training-options">
              <div class="training-option" onclick="selectTrainingOption(this, 'fold')">FOLD</div>
              <div class="training-option" onclick="selectTrainingOption(this, 'check')">CHECK</div>
              <div class="training-option" onclick="selectTrainingOption(this, 'call')">CALL</div>
              <div class="training-option" onclick="selectTrainingOption(this, 'raise')">RAISE</div>
              <div class="training-option" onclick="selectTrainingOption(this, 'bluff')">BLUFF</div>
            </div>
          </div>
        `;
      }

      body.innerHTML = html;
      toggleModal('trainingModal');
    }

    function selectTrainingOption(el, value) {
      el.parentNode.querySelectorAll('.training-option').forEach(opt => opt.classList.remove('selected'));
      el.classList.add('selected');
      el.dataset.value = value;
    }

    function submitTrainingForm() {
      try {
        console.log("Submitting Training Form...");
        const feedback = document.getElementById('trainingFeedback');
        const stepId = currentTrainingStep;

        if (!stepId) {
          console.warn("No step selected");
          return;
        }

        let isCorrect = false;
        let message = '';

        if (stepId === 'position') {
          const selected = document.querySelector('.training-option.selected');
          if (!selected) return alert('Select an option!');
          const val = selected.dataset.value;
          const actual = game.getPlayerPosition(0);
          isCorrect = (val === actual || (val === 'dealer' && actual === 'late'));
          message = isCorrect ? `<strong>Correct!</strong> You are in the ${actual.toUpperCase()} position.` : `<strong>Not quite.</strong> You are actually in the ${actual.toUpperCase()} position. Look at your seat relative to the 'D' button!`;
        } else if (stepId === 'preflop') {
          const selected = document.querySelector('.training-option.selected');
          if (!selected) return alert('Select an option!');
          const val = selected.dataset.value;
          const player = game.players[0];
          if (!player) throw new Error("Human player not found");

          const strength = game.evaluatePreFlopHand(player.hand);
          const category = game.learningEngine.getHandCategory(player.hand);

          isCorrect = (val === category);
          if (isCorrect) {
            message = `<strong>Spot on!</strong> This is a ${category.toUpperCase()} hand.<br><br><button class="submit-training-btn" style="width:100%;" onclick="toggleCharts()">Open GTO Opening Chart</button>`;
          } else {
            message = `<strong>Careful.</strong> This hand is actually ${category.toUpperCase()}.<br><br>üéì <strong>Tutor Tip:</strong> Preflop strength is based on high-card value and 'connectedness' (like 9-10 suited). High pairs are always Premium!`;
          }
        } else if (stepId === 'math') {
          const outsInput = document.getElementById('train-outs');
          const equityInput = document.getElementById('train-equity');
          const oddsInput = document.getElementById('train-pot-odds');

          if (!outsInput || !equityInput || !oddsInput) {
            throw new Error("Form inputs missing from DOM");
          }

          const userOuts = parseInt(outsInput.value || 0);
          const userEquity = parseInt(equityInput.value || 0);
          const userPotOdds = parseInt(oddsInput.value || 0);

          const player = game.players[0];
          if (!player) throw new Error("Human player not found");

          // Ensure equity is calculated if it somehow isn't
          if (player.equity === undefined && game.communityCards.length > 0) {
            game.updatePlayerEquity();
          }
          const actualEquity = Math.round((player.equity || 0) * 100);
          const outsData = game.learningEngine ? game.learningEngine.calculateOuts(player.hand, game.communityCards) : { total: 0 };
          const actualOuts = outsData.total;

          // Calculate actual Pot Odds
          const callAmount = game.currentBet - player.currentBet;
          const divisor = game.pot + callAmount;
          const potOddsRaw = (callAmount > 0 && divisor > 0) ? callAmount / divisor : 0;
          const actualPotOdds = Math.round(potOddsRaw * 100);

          const multiplier = (game.gamePhase === 'flop' ? 4 : 2);
          const heuristicEquity = actualOuts * multiplier;
          const matchesActual = (Math.abs(userEquity - actualEquity) <= 7);
          const matchesHeuristic = (Math.abs(userEquity - heuristicEquity) <= 7);
          const matchesPotOdds = (Math.abs(userPotOdds - actualPotOdds) <= 5); // 5% leniency for pot odds

          isCorrect = (matchesActual || matchesHeuristic) && (callAmount <= 0 || matchesPotOdds);

          let tutorMsg = `<strong>Result:</strong><br>`;
          tutorMsg += `‚Ä¢ Actual Equity: ${actualEquity}%<br>`;
          tutorMsg += `‚Ä¢ Pot Odds: ${actualPotOdds}%<br><br>`;

          if (isCorrect) {
            tutorMsg += `<strong>Great job!</strong> Your estimate is within the professional margin of error. `;
            if (matchesHeuristic && !matchesActual && Math.abs(actualEquity - heuristicEquity) > 10) {
              tutorMsg += `<br><br>üéì <strong>Tutor Tip:</strong> Your Rule of ${multiplier} math (${heuristicEquity}%) is correct! Note that your real equity is lower (${actualEquity}%) because you are in a multi-way pot or your outs are 'dirty'.`;
            } else {
              tutorMsg += `You've mastered the Rule of 2 & 4 and Pot Odds!`;
            }
          } else {
            tutorMsg += `<strong>üéì How to calculate:</strong><br>`;
            if (game.gamePhase === 'preflop') {
              tutorMsg += `Preflop, focus on <strong>Hole Card Strength</strong>. Equity here is based on your cards' power against random hands.`;
            } else {
              tutorMsg += `1. <strong>Count your Outs:</strong> You have ${actualOuts} cards that would give you the best hand.<br>`;
              tutorMsg += `2. <strong>Equity:</strong> ${actualOuts} outs √ó ${multiplier} = ~${heuristicEquity}% Equity.<br>`;
              tutorMsg += `3. <strong>Pot Odds:</strong> To call $${callAmount} into a $${game.pot} pot, you need ${actualPotOdds}% equity.`;

              if (actualEquity >= actualPotOdds) {
                tutorMsg += `<br><br>‚úîÔ∏è <strong>Verdict:</strong> Since Equity (${actualEquity}%) ‚â• Pot Odds (${actualPotOdds}%), this is a mathematically profitable CALL.`;
              } else {
                tutorMsg += `<br><br>‚ùå <strong>Verdict:</strong> Since Equity (${actualEquity}%) < Pot Odds (${actualPotOdds}%), you don't have enough value to call unless you have 'Implied Odds'.`;
              }
            }
          }
          message = tutorMsg;
        } else if (stepId === 'decision') {
          const selected = document.querySelector('.training-option.selected');
          if (!selected) return alert('Select an option!');
          const val = selected.dataset.value;
          const rec = game.getOptimalActionForPlayer();

          if (!rec) {
            message = "<strong>Analysis Unavailable.</strong> The Coach can only analyze your current live hand. Start a new hand or advance to your turn!";
            isCorrect = false;
          } else {
            isCorrect = (val === rec.action.toLowerCase() || (val === 'bluff' && rec.action === 'raise'));
            const explanation = rec.explanation || "No detailed explanation available.";
            if (isCorrect) {
              message = `<strong>Excellent choice!</strong> The GTO play is indeed ${rec.action.toUpperCase()}. ${explanation}`;
            } else {
              message = `<strong>The Coach disagrees.</strong> The recommendation is ${rec.action.toUpperCase()}.<br><br>üéì <strong>Why?</strong> ${explanation}`;
            }
          }
        }

        if (feedback) {
          feedback.innerHTML = message;
          feedback.style.display = 'block';
          feedback.className = `feedback-area ${isCorrect ? 'correct' : 'incorrect'}`;
        }

        if (isCorrect && window.soundManager) soundManager.playWinner();
        else if (window.soundManager) soundManager.playCheck();
      } catch (err) {
        console.error("Training Form Error:", err);
        alert("Training Error: " + err.message);
      }
    }
  </script>
</body>

</html>